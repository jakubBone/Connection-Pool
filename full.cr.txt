====================
FILE: ConnectionPool.java

package connection_pool;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import database.DatabaseConnection;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;

@Log4j2
@Getter
public class ConnectionPool {
    private final int minPoolSize;
    private final int maxPoolSize;
    private List<Connection> pool;
    private Semaphore semaphore;
    private Lock lock;
    private ScheduledExecutorService scheduler;

    public ConnectionPool(int minPoolSize, int maxPoolSize) {
        this.minPoolSize = minPoolSize;
        this.maxPoolSize = maxPoolSize;
        this.pool = new ArrayList<>();
        semaphore = new Semaphore(maxPoolSize, true);
        lock = new ReentrantLock();
        initPool();
    }

    public void initPool()  {
        lock.lock();
        try {
            for (int i = 0; i < minPoolSize; i++) {
                pool.add(new DatabaseConnection().getConnection());
                System.out.println("A new connection added to POOL");
            }
        } catch (SQLException ex) {
            System.out.println("Error initializing connection POOL");
        } finally {
            lock.unlock();
        }
    }

    public Connection getConnection() throws SQLException {
        try {
            semaphore.acquire();
            lock.lock();
            try {
                for (Connection conn: pool) {
                    if (!conn.isClosed()) {
                        pool.remove(conn);
                        System.out.println(Thread.currentThread() + " got a connection from the POOL");
                        return conn;
                    }
                }
                if (pool.size() < maxPoolSize) {
                    Connection newConn = new DatabaseConnection().getConnection();
                    pool.add(newConn);
                    System.out.println(Thread.currentThread() + " added a new connection from the POOL");
                    return newConn;
                } else {
                    throw new SQLException("No available connections");
                }
            } finally {
                lock.unlock();
            }
        } catch (InterruptedException ex) {
            throw new SQLException("Failed to acquire a connection: {} ", ex.getMessage());
        }
    }

    public void releaseConnection(Connection conn) throws SQLException {
        lock.lock();
        try {
            if (!conn.isClosed()) {
                pool.add(conn);
                System.out.println(Thread.currentThread() + " returned the connection to the POOL");
                semaphore.release();
            } else {
                pool.remove(conn);
                System.out.println("Connection with error removed from POOL");
                if (pool.size() < minPoolSize) {
                    pool.add(new DatabaseConnection().getConnection());
                }
            }
        } catch (SQLException ex) {
            pool.remove(conn);
            System.out.println("Connection with error removed from POOL");
            if (pool.size() < minPoolSize) {
                pool.add(new DatabaseConnection().getConnection());
            }
        } finally {
            lock.unlock();
        }
    }

    public void startCleanupScheduler()  {
        System.out.println("Scheduler started");
        scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(() -> {
            try {
                removeIdleConnection();
            } catch (Exception ex) {
                System.out.println("Failed to remove connection: " + ex.getMessage());
            }
        }, 0, 1, TimeUnit.MINUTES);
    }

    public void removeIdleConnection() throws SQLException {
        lock.lock();
        try {
            for (Connection conn: pool) {
                if (conn.isClosed() && pool.size() > minPoolSize) {
                    pool.remove(conn);
                    System.out.println(Thread.currentThread() + " removed the idle connection from POOL");
                }
            }
        } finally {
            lock.unlock();
        }
    }

    public void stopCleanupScheduler() throws InterruptedException {
        if (scheduler != null && !scheduler.isShutdown()) {
            scheduler.shutdown();
            try {
                if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                    scheduler.shutdownNow();
                }
            } catch (InterruptedException ex) {
                System.out.println("Scheduler shut down");
                scheduler.shutdownNow();
            }
        }
    }
}

====================
FILE: ConnectionPoolTester.java

package connection_pool;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ConnectionPoolTester {
    private static final int MIN_POOL_SIZE = 10;
    private static final int MAX_POOL_SIZE = 100;
    private static final int NUMBER_OF_THREADS = 200;
    private static final long TEST_DURATION_IN_SECONDS = 30;

    public static void main(String[] args) {
        System.out.println("\n======== TEST START ========\n");

        ConnectionPoolTester test = new ConnectionPoolTester();
        test.runTest();

        System.out.println("\n======== TEST STOP ========");
    }

        private void runTest() {
            ConnectionPool connectionPool = new ConnectionPool(MIN_POOL_SIZE, MAX_POOL_SIZE);
            startCleanup(connectionPool);

            Runnable task = createTask(connectionPool);
            ExecutorService executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS);
            for (int i = 0; i < NUMBER_OF_THREADS; i++) {
                executor.submit(task);
            }

            shutDownExecutor(executor);
            stopCleanup(connectionPool);
        }

        private Runnable createTask(ConnectionPool connectionPool) {
            return () -> {
                long endTime = System.currentTimeMillis() + TEST_DURATION_IN_SECONDS * 1000;
                while (System.currentTimeMillis() < endTime) {
                    Connection connection = null;
                    try {
                        // CONNECTION GETTING
                        connection = connectionPool.getConnection();

                        // WORK SIMULATION
                        System.out.println(Thread.currentThread() + " is working");
                        Thread.sleep(100);
                    } catch (SQLException | InterruptedException ex) {
                        System.out.println("Exception: " + ex.getMessage());
                        Thread.currentThread().interrupt();
                    } finally {
                        if (connection != null) {
                            try {
                                // CONNECTION RELEASING
                                connectionPool.releaseConnection(connection);
                            } catch (SQLException ex) {
                                System.out.println("Failed to release connection: " + ex.getMessage());
                            }
                        }
                    }
                }
            };
        }

        private void shutDownExecutor(ExecutorService executor) {
            executor.shutdown();
            try {
                if (!executor.awaitTermination(TEST_DURATION_IN_SECONDS + 10, TimeUnit.SECONDS)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException ex) {
                System.out.println("Test interrupted: " + ex.getMessage());
                executor.shutdownNow();
            }
        }

        private void startCleanup(ConnectionPool connection) {
            connection.startCleanupScheduler();
        }

        private void stopCleanup(ConnectionPool connection) {
            try {
                connection.stopCleanupScheduler();
            } catch (InterruptedException ex) {
                System.out.println("Failed to shutdown connection pool: " + ex.getMessage());
            }
        }
}

====================
FILE: DatabaseConnection.java

package database;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import lombok.Setter;
import lombok.extern.log4j.Log4j2;

@Log4j2
public class DatabaseConnection {
    private final String USER = "jakub_bone";
    private final String PASSWORD = "password123";
    private final String DATABASE = "connection_db";
    private final int PORT_NUMBER = 5432;
    private final String URL = String.format("jdbc:postgresql://localhost:%d/%s", PORT_NUMBER, DATABASE);
    private static Connection connection;

    public Connection getConnection() throws SQLException {
        if (connection == null || connection.isClosed()) {
            try {
                log.info("Attempting to connect to the database");
                connection = DriverManager.getConnection(URL, USER, PASSWORD);
                log.info("Connection established with {} on port {}", DATABASE, PORT_NUMBER);
            } catch (SQLException ex) {
                log.error("Error during database connection: {}", ex.getMessage());
                throw ex;
            }
        }
        return connection;
    }

    public void disconnect() {
        try {
            if (connection != null) {
                connection.close();
                log.info("Database disconnected");
            }
        } catch(SQLException ex){
            log.error("Error during database disconnection: {}", ex.getMessage());
        }
    }
}

